[{"name":"ReviewPipelineStyles","comment":"\n\n@docs rule\n\n\n# Config\n\n@docs PipelineRule, forbid, that, exceptThoseThat\n\n\n## Failures\n\n@docs byReportingError\n\n\n## Pipeline Types\n\n@docs rightPizzaPipelines, leftPizzaPipelines, rightCompositionPipelines, leftCompositionPipelines, parentheticalApplicationPipelines\n\n\n## Creating Predicates\n\n@docs and, or, doNot\n\n\n## Predicates\n\n@docs spanMultipleLines, haveMoreStepsThan, haveFewerStepsThan, haveASimpleInput, haveAnInputOf\n\n\n## Manual Predicates\n\nIf you need predicates beyond what is provided above, you can create them\nmanually by simply writing a function of type `Pipeline -> Bool`.\n\n@docs Pipeline\n\n\n### Types\n\nThese are exposed only for the sake of type annotations; you shouldn't need to\nwork with them directly.\n\n@docs Predicate, Operator\n\n","unions":[{"name":"Operator","comment":" The operator type of a pipeline.\n\n  - `RightPizza` -- `|>`\n  - `LeftPizza` -- `<|`\n  - `RightComposition` -- `>>`\n  - `LeftComposition` -- `<<`\n  - `ParentheticalApplication` -- `foo (bar (baz (i (j k))))`\n\n","args":[],"cases":[]},{"name":"PipelineRule","comment":" Configuration of this rule is in the form of a list of `PipelineRule`s. It\nshould be noted that these are hierarchical, i.e. only the first matching error\nwill be generated in the event that a pipeline would generate multiple errors.\n\nTo create a new `PipelineRule`, use [`forbid`](#forbid), then a pipeline type,\nthen the desired predicates and error. If no predicates are provided, the rule\nmatches **all** pipelines of that type. For example, to entirely forbid `<|` in\nyour project, you could use:\n\n    forbid leftPizzaPipelines\n        |> byReportingError \"Forbidden <| pipeline!\" [ \"Left application pipelines are forbidden in this project, so please remove it.\" ]\n\nOr, to forbid only `|>` pipelines that are extremely long, you could use:\n\n    forbid rightPizzaPipelines\n        |> that (haveMoreStepsThan 10)\n        |> byReportingError \"Overly long |> pipeline!\" [ \"Right application pipelines may only be a maximum of 11 steps long in this project, so please remove it.\" ]\n\n","args":["a"],"cases":[]},{"name":"Predicate","comment":" A predicate for filtering pipelines, or a logical combination of them.\n","args":[],"cases":[]}],"aliases":[{"name":"Pipeline","comment":" A detected pipeline. You only need be concerned with this type if you are\nwriting a manual predicate. Note that the types contained within this are from\n[`stil4m/elm-syntax`](https://package.elm-lang.org/packages/stil4m/elm-syntax/7.2.7/)\nif you need to work with them directly.\n\n  - `operator`: The operator that was detected\n  - `steps`: The steps of the pipeline. Note that this is in \"logical\" order,\n    e.g. `a >> b >> c`, `c << b << a`, `a |> b |> c`, `c <| b <| a`, and\n    `c (b a)` will all have the same steps of `[a, b, c]`.\n  - `node`: The outermost `Node` of the pipeline; you probably don't need to\n    work with this directly.\n\n","args":[],"type":"{ operator : ReviewPipelineStyles.Operator, steps : List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression), node : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression }"}],"values":[{"name":"and","comment":" Create a `Predicate` that matches pipelines that match both of two\npredicates.\n","type":"ReviewPipelineStyles.Predicate -> ReviewPipelineStyles.Predicate -> ReviewPipelineStyles.Predicate"},{"name":"byReportingError","comment":" Provide a message and details to forbid pipelines by reporting an error\nwithout a fix. If you don't pass any error to a `PipelineRule`, you will get a\ngeneric error message that isn't very helpful, so you should always specify an\nerror!\n","type":"String.String -> List.List String.String -> ReviewPipelineStyles.PipelineRule { r | hasNoError : () } -> ReviewPipelineStyles.PipelineRule { r | hasError : () }"},{"name":"doNot","comment":" Negate a `Predicate`.\n","type":"ReviewPipelineStyles.Predicate -> ReviewPipelineStyles.Predicate"},{"name":"exceptThoseThat","comment":" Exclude (whitelist) pipelines that match a predicate from being forbidden.\n\n    forbid rightPizzaPipelines\n        |> that spanMultipleLines\n        |> exceptThoseThat (haveMoreStepsThan 5)\n\n","type":"ReviewPipelineStyles.Predicate -> ReviewPipelineStyles.PipelineRule { r | hasNoException : () } -> ReviewPipelineStyles.PipelineRule { r | hasException : () }"},{"name":"forbid","comment":" Forbid certain pipelines.\n","type":"ReviewPipelineStyles.Operator -> ReviewPipelineStyles.PipelineRule { hasNoLimit : (), hasNoException : (), hasNoError : () }"},{"name":"haveASimpleInput","comment":" Determine whether the pipeline has a simple input or not. This is somewhat\nsubjective, of course, so use [`haveAnInputOf`](#haveAnInputOf) if you want to customize its\nbehavior. A pipeline is considered to have a simple input if its input is **40\ncharacters or less**, is only a **single line**, and also:\n\nIs one of the following:\n\n    -- Unit\n    ()\n        |> foo\n\n    -- Name\n    a\n        |> foo\n\n    -- Prefix operator\n    (+)\n        |> foo\n\n    -- Int literal\n    1\n        |> foo\n\n    -- Hex literal\n    0x0F\n        |> foo\n\n    -- Float literal\n    1.5\n        |> foo\n\n    -- String literal\n    \"bar\"\n        |> foo\n\n    -- Char literal\n    'c'\n        |> foo\n\n    -- Record access function\n    .field\n        |> foo\n\nor is one of the following where all subexpressions are simple:\n\n    -- Tuple\n    ( a, \"b\" )\n        |> foo\n\n    -- Record\n    { a = \"value\" }\n        |> foo\n\n    -- List\n    []\n        |> foo\n\n    -- Record access\n    a.field\n        |> foo\n\n    -- Negation\n    elmFormatWontLetThisBeAnExample\n        |> foo\n\n    -- Parentheses\n    elmFormatWontLetThisBeAnExample\n        |> foo\n\n","type":"ReviewPipelineStyles.Predicate"},{"name":"haveAnInputOf","comment":" Like [`haveASimpleInput`](#haveASimpleInput) but with a user-providable\nfunction to check if an expression is simple.\n","type":"(Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression -> Basics.Bool) -> ReviewPipelineStyles.Predicate"},{"name":"haveFewerStepsThan","comment":" Checks whether the length of a pipeline is less than a specified number.\nNote that the length of a pipeline is the number of operators in it, e.g.\n\n    foo\n        |> bar\n        |> baz\n\nhas length **2** for the purposes of this predicate.\n\n","type":"Basics.Int -> ReviewPipelineStyles.Predicate"},{"name":"haveMoreStepsThan","comment":" Checks whether the length of a pipeline is longer than a specified number.\nNote that the length of a pipeline is the number of operators in it, e.g.\n\n    foo\n        |> bar\n        |> baz\n\nhas length **2** for the purposes of this predicate.\n\n","type":"Basics.Int -> ReviewPipelineStyles.Predicate"},{"name":"leftCompositionPipelines","comment":" The left composition operator is left function composition, i.e. `<<`. An\nexample of this pipeline is below:\n\n    foo << bar << baz\n\n","type":"ReviewPipelineStyles.Operator"},{"name":"leftPizzaPipelines","comment":" The left \"pizza\" operator is left function application, i.e. `<|`. An\nexample of this pipeline is below:\n\n    foo <| bar <| baz\n\n","type":"ReviewPipelineStyles.Operator"},{"name":"or","comment":" Create a `Predicate` that matches pipelines that match either or both of two\npredicates.\n","type":"ReviewPipelineStyles.Predicate -> ReviewPipelineStyles.Predicate -> ReviewPipelineStyles.Predicate"},{"name":"parentheticalApplicationPipelines","comment":" Parenthetical application is actually the absence of a pipeline, but rather\nsuccessive function calls using parentheses, e.g.\n\n    foo (bar (baz (i (j k))))\n\n","type":"ReviewPipelineStyles.Operator"},{"name":"rightCompositionPipelines","comment":" The right composition operator is right function composition, i.e. `>>`. An\nexample of this pipeline is below:\n\n    foo\n        >> bar\n        >> baz\n\n","type":"ReviewPipelineStyles.Operator"},{"name":"rightPizzaPipelines","comment":" The right \"pizza\" operator is right function application, i.e. `|>`. An\nexample of this pipeline is below:\n\n    foo\n        |> bar\n        |> baz\n\n","type":"ReviewPipelineStyles.Operator"},{"name":"rule","comment":" Reports pipelines that are not valid by user-defined rules. For example,\nthe usage of `<|` or the usage of excessively-long `|>` pipelines.\n\n    config =\n        [ ReviewPipelineStyles.rule\n            [ forbid leftPizzaPipelines\n                |> byReportingError \"Forbidden <| pipeline!\" [ \"Left application pipelines are forbidden in this project, so please remove it.\" ]\n            , forbid rightPizzaPipelines\n                |> that (haveMoreStepsThan 10)\n                |> byReportingError \"Overly long |> pipeline!\" [ \"Right application pipelines may only be a maximum of 11 steps long in this project, so please remove it.\" ]\n            ]\n        ]\n\nThis rule works with the following pipeline types:\n\n  - `|>`\n  - `<|`\n  - `>>`\n  - `<<`\n  - `foo (bar (baz (i (j k))))`\n\n\n## Fail\n\nBy the above config:\n\n    a =\n        Just <| foo bar\n\n    b =\n        foo\n            |> bar\n            |> baz\n            |> a\n            |> b\n            |> c\n            |> d\n            |> e\n            |> f\n            |> g\n            |> h\n            |> i\n            |> j\n            |> k\n\n\n## Success\n\nBy the above config:\n\n    a =\n        foo bar\n            |> Just\n\n    b =\n        foo\n            |> bar\n            |> baz\n            |> a\n            |> b\n            |> c\n            |> d\n\n\n## When (not) to enable this rule\n\nThis rule is useful when you have strong opinions about how functions should be\ncomposed/applied and/or want to enforce consistent code style in a project.\n\nThis rule is not useful if you don't care what sorts of pipelines are used in a\nproject.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template SiriusStarr/elm-review-pipeline-styles/example --rules ReviewPipelineStyles\n```\n\n","type":"List.List (ReviewPipelineStyles.PipelineRule r) -> Review.Rule.Rule"},{"name":"spanMultipleLines","comment":" Checks whether or not a pipeline spans multiple lines of code.\n","type":"ReviewPipelineStyles.Predicate"},{"name":"that","comment":" Limit (blacklist) forbidden pipelines to those that match a specific\npredicate.\n\n    forbid rightPizzaPipelines\n        |> that spanMultipleLines\n\n","type":"ReviewPipelineStyles.Predicate -> ReviewPipelineStyles.PipelineRule { r | hasNoLimit : () } -> ReviewPipelineStyles.PipelineRule { r | hasLimit : () }"}],"binops":[]}]