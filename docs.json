[{"name":"ReviewPipelineStyles","comment":"\n\n@docs rule\n\n\n# Config\n\n@docs PipelineRule, forbid, that, exceptThoseThat\n\n\n## Failures\n\n@docs byReportingError\n\n\n## Pipeline Types\n\n@docs rightPizzaPipelines, leftPizzaPipelines, rightCompositionPipelines, leftCompositionPipelines, parentheticalApplicationPipelines\n\n","unions":[{"name":"PipelineRule","comment":" Configuration of this rule is in the form of a list of `PipelineRule`s. It\nshould be noted that these are hierarchical, i.e. only the first matching error\nwill be generated in the event that a pipeline would generate multiple errors.\n\nTo create a new `PipelineRule`, use [`forbid`](#forbid), then a pipeline type,\nthen the desired predicates and error. If no predicates are provided, the rule\nmatches **all** pipelines of that type. For example, to entirely forbid `<|` in\nyour project, you could use:\n\n    forbid leftPizzaPipelines\n        |> byReportingError \"Forbidden <| pipeline!\" [ \"Left application pipelines are forbidden in this project, so please remove it.\" ]\n\nOr, to forbid only `|>` pipelines that are extremely long, you could use:\n\n    forbid rightPizzaPipelines\n        |> that (haveMoreStepsThan 10)\n        |> byReportingError \"Overly long |> pipeline!\" [ \"Right application pipelines may only be a maximum of 11 steps long in this project, so please remove it.\" ]\n\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"byReportingError","comment":" Provide a message and details to forbid pipelines by reporting an error\nwithout a fix. If you don't pass any error to a `PipelineRule`, you will get a\ngeneric error message that isn't very helpful, so you should always specify an\nerror!\n","type":"String.String -> List.List String.String -> ReviewPipelineStyles.PipelineRule r -> ReviewPipelineStyles.PipelineRule r"},{"name":"exceptThoseThat","comment":" Exclude (whitelist) pipelines that match a predicate from being forbidden.\n\n    forbid rightPizzaPipelines\n        |> that spanMultipleLines\n        |> exceptThoseThat (haveMoreStepsThan 5)\n\nNote that if `exceptThoseThat` is used multiple times, it is equivalent to using\n[`or`](#or). For example, the following two rules are equivalent:\n\n    forbid leftPizzaPipelines\n        |> exceptThoseThat\n            (doNot spanMultipleLines\n                |> or (haveFewerStepsThan 2)\n            )\n\n    forbid rightPizzaPipelines\n        |> exceptThoseThat (doNot spanMultipleLines)\n        |> exceptThoseThat (haveFewerStepsThan 2)\n\n","type":"ReviewPipelineStyles.Predicates.Predicate -> ReviewPipelineStyles.PipelineRule r -> ReviewPipelineStyles.PipelineRule r"},{"name":"forbid","comment":" Forbid certain pipelines.\n","type":"ReviewPipelineStyles.Predicates.Operator -> ReviewPipelineStyles.PipelineRule ()"},{"name":"leftCompositionPipelines","comment":" The left composition operator is left function composition, i.e. `<<`. An\nexample of this pipeline is below:\n\n    foo << bar << baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator"},{"name":"leftPizzaPipelines","comment":" The left \"pizza\" operator is left function application, i.e. `<|`. An\nexample of this pipeline is below:\n\n    foo <| bar <| baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator"},{"name":"parentheticalApplicationPipelines","comment":" Parenthetical application is actually the absence of a pipeline, but rather\nsuccessive function calls using parentheses, e.g.\n\n    foo (bar (baz (i (j k))))\n\n","type":"ReviewPipelineStyles.Predicates.Operator"},{"name":"rightCompositionPipelines","comment":" The right composition operator is right function composition, i.e. `>>`. An\nexample of this pipeline is below:\n\n    foo\n        >> bar\n        >> baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator"},{"name":"rightPizzaPipelines","comment":" The right \"pizza\" operator is right function application, i.e. `|>`. An\nexample of this pipeline is below:\n\n    foo\n        |> bar\n        |> baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator"},{"name":"rule","comment":" Reports pipelines that are not valid by user-defined rules. For example,\nthe usage of `<|` or the usage of excessively-long `|>` pipelines.\n\n    config =\n        [ ReviewPipelineStyles.rule\n            [ forbid leftPizzaPipelines\n                |> byReportingError \"Forbidden <| pipeline!\" [ \"Left application pipelines are forbidden in this project, so please remove it.\" ]\n            , forbid rightPizzaPipelines\n                |> that (haveMoreStepsThan 10)\n                |> byReportingError \"Overly long |> pipeline!\" [ \"Right application pipelines may only be a maximum of 11 steps long in this project, so please remove it.\" ]\n            ]\n        ]\n\nThis rule works with the following pipeline types:\n\n  - `|>`\n  - `<|`\n  - `>>`\n  - `<<`\n  - `foo (bar (baz (i (j k))))`\n\n\n## Fail\n\nBy the above config:\n\n    a =\n        Just <| foo bar\n\n    b =\n        foo\n            |> bar\n            |> baz\n            |> a\n            |> b\n            |> c\n            |> d\n            |> e\n            |> f\n            |> g\n            |> h\n            |> i\n            |> j\n            |> k\n\n\n## Success\n\nBy the above config:\n\n    a =\n        foo bar\n            |> Just\n\n    b =\n        foo\n            |> bar\n            |> baz\n            |> a\n            |> b\n            |> c\n            |> d\n\n\n## When (not) to enable this rule\n\nThis rule is useful when you have strong opinions about how functions should be\ncomposed/applied and/or want to enforce consistent code style in a project.\n\nThis rule is not useful if you don't care what sorts of pipelines are used in a\nproject.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template SiriusStarr/elm-review-pipeline-styles/example --rules ReviewPipelineStyles\n```\n\n","type":"List.List (ReviewPipelineStyles.PipelineRule r) -> Review.Rule.Rule"},{"name":"that","comment":" Limit (blacklist) forbidden pipelines to those that match a specific\npredicate.\n\n    forbid rightPizzaPipelines\n        |> that spanMultipleLines\n\nNote that if `that` is used multiple times, it is equivalent to using\n[`or`](#or). For example, the following two rules are equivalent:\n\n    forbid rightPizzaPipelines\n        |> that\n            (spanMultipleLines\n                |> or (haveMoreStepsThan 5)\n            )\n\n    forbid rightPizzaPipelines\n        |> that spanMultipleLines\n        |> that (haveMoreStepsThan 5)\n\n","type":"ReviewPipelineStyles.Predicates.Predicate -> ReviewPipelineStyles.PipelineRule r -> ReviewPipelineStyles.PipelineRule r"}],"binops":[]},{"name":"ReviewPipelineStyles.Predicates","comment":" This module contains various `Predicate`s that can be used to filter pipelines.\n\n\n## Combining Predicates\n\n@docs and, or, doNot\n\n\n## Predicates\n\n@docs spanMultipleLines, haveMoreStepsThan, haveFewerStepsThan, haveASimpleInput, haveAnInputOf, separateATestFromItsLambda\n\n\n## Nesting Predicates\n\n@docs haveAParent, haveAParentNotSeparatedBy, haveMoreNestedParentsThan, aLetBlock, aLambdaFunction, aFlowControlStructure, aDataStructure\n\n\n## Custom Predicates\n\nIf you need predicates beyond what is provided above, you can create them\nmanually by writing a function of type `Pipeline -> Bool` or\n`ModuleNameLookupTable -> Pipeline -> Bool` and using one of the functins below.\n\nUse the functions in\n[Getting Information About Pipelines](#getting-information-about-pipelines) to\nbuild your custom predicate.\n\n@docs predicate, predicateWithLookupTable\n\n\n## Getting Information About Pipelines\n\nNote that some of the types returned by these functions are from\n[`stil4m/elm-syntax`](https://package.elm-lang.org/packages/stil4m/elm-syntax/7.2.7/)\nif you need to work with them directly.\n\n@docs getSteps, getParents, getNode\n\n\n### Types\n\nThese are exposed only for the sake of type annotations; you shouldn't need to\nwork with them directly.\n\n@docs Predicate, Operator, Pipeline, NestedWithin\n\n","unions":[],"aliases":[{"name":"NestedWithin","comment":" The degree to which a parent or child is removed from a pipeline.\n","args":[],"type":"Internal.Types.NestedWithin"},{"name":"Operator","comment":" The operator type of a pipeline, e.g. `|>` or `<<`.\n","args":[],"type":"Internal.Types.Operator"},{"name":"Pipeline","comment":" A detected pipeline. You only need be concerned with this type if you are\nwriting a manual predicate.\n","args":[],"type":"Internal.Types.Pipeline"},{"name":"Predicate","comment":" A predicate for filtering pipelines, or a logical combination of them.\n","args":[],"type":"Internal.Types.Predicate"}],"values":[{"name":"aDataStructure","comment":" Within a tuple, list, or record in the surrounding pipeline.\n","type":"ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool"},{"name":"aFlowControlStructure","comment":" Within a `case` expression of `if...then` expression in the surrounding\npipeline.\n","type":"ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool"},{"name":"aLambdaFunction","comment":" Within a lambda function in the surrounding pipeline.\n","type":"ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool"},{"name":"aLetBlock","comment":" Either within a `let` declaration or in the `let` expression of a `let`\nblock from the surrounding pipeline.\n","type":"ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool"},{"name":"and","comment":" Create a `Predicate` that matches pipelines that match both of two\npredicates.\n","type":"ReviewPipelineStyles.Predicates.Predicate -> ReviewPipelineStyles.Predicates.Predicate -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"doNot","comment":" Negate a `Predicate`.\n","type":"ReviewPipelineStyles.Predicates.Predicate -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"getNode","comment":" Get the outermost `Node` of a pipeline; you probably don't need to work with\nthis directly.\n","type":"ReviewPipelineStyles.Predicates.Pipeline -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression"},{"name":"getParents","comment":" Get the \"parent\" pipelines of the pipeline, i.e. a hierarchy of pipelines\nthat this pipeline is nested within (start of the list being the most immediate\nparent). Note that you can use the functions in\n[Nesting Predicates](#nesting-predicates) to interrogate the `NestedWithin`\ntype and in [Pipeline Types](ReviewPipelineStyles#pipeline-types) for the\n`Operator` type.\n","type":"ReviewPipelineStyles.Predicates.Pipeline -> List.List ( ReviewPipelineStyles.Predicates.Operator, ReviewPipelineStyles.Predicates.NestedWithin )"},{"name":"getSteps","comment":" Get the \"steps\" in the pipeline. Note that this is in \"logical\" order, e.g.\n`a 1 >> b >> c`, `c << b << a 1`, `a 1 |> b |> c`, `c <| b <| a 1`, and\n`c (b (a 1))` will all have the same steps of `[a 1, b, c]`.\n","type":"ReviewPipelineStyles.Predicates.Pipeline -> List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression)"},{"name":"haveAParent","comment":" Checks whether the pipeline is nested to any degree within another pipeline.\nNote that this is quite a strict requirement and you probably want to use one of\nthe other nesting predicates instead.\n","type":"ReviewPipelineStyles.Predicates.Predicate"},{"name":"haveAParentNotSeparatedBy","comment":" Checks whether the immediate parent of a pipeline (if one exists) is not\nseparated by one of a list of acceptable abstractions.\n","type":"List.List (ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool) -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"haveASimpleInput","comment":" Determine whether the pipeline has a simple input or not. This is somewhat\nsubjective, of course, so use [`haveAnInputOf`](#haveAnInputOf) if you want to customize its\nbehavior. A pipeline is considered to have a simple input if its input is **40\ncharacters or less**, is only a **single line**, and also:\n\nIs one of the following:\n\n    -- Unit\n    ()\n        |> foo\n\n    -- Name\n    a\n        |> foo\n\n    -- Prefix operator\n    (+)\n        |> foo\n\n    -- Int literal\n    1\n        |> foo\n\n    -- Hex literal\n    0x0F\n        |> foo\n\n    -- Float literal\n    1.5\n        |> foo\n\n    -- String literal\n    \"bar\"\n        |> foo\n\n    -- Char literal\n    'c'\n        |> foo\n\n    -- Record access function\n    .field\n        |> foo\n\nor is one of the following where all subexpressions are simple:\n\n    -- Tuple\n    ( a, \"b\" )\n        |> foo\n\n    -- Record\n    { a = \"value\" }\n        |> foo\n\n    -- List\n    []\n        |> foo\n\n    -- Record access\n    a.field\n        |> foo\n\n    -- Negation\n    elmFormatWontLetThisBeAnExample\n        |> foo\n\n    -- Parentheses\n    elmFormatWontLetThisBeAnExample\n        |> foo\n\n","type":"ReviewPipelineStyles.Predicates.Predicate"},{"name":"haveAnInputOf","comment":" Like [`haveASimpleInput`](#haveASimpleInput) but with a user-providable\nfunction to check if an expression is simple.\n","type":"(Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression -> Basics.Bool) -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"haveFewerStepsThan","comment":" Checks whether the length of a pipeline is less than a specified number.\nNote that the length of a pipeline is the number of operators in it, e.g.\n\n    foo\n        |> bar\n        |> baz\n\nhas length **2** for the purposes of this predicate.\n\n","type":"Basics.Int -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"haveMoreNestedParentsThan","comment":" Checks whether the pipeline is nested to a greater degree than specified\nwithin other pipelines. For example, `haveMoreNestedParentsThan 1` will forbid\n\n    a =\n        foo\n            |> (bar <| (a |> b |> c))\n            |> baz\n\n","type":"Basics.Int -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"haveMoreStepsThan","comment":" Checks whether the length of a pipeline is longer than a specified number.\nNote that the length of a pipeline is the number of operators in it, e.g.\n\n    foo\n        |> bar\n        |> baz\n\nhas length **2** for the purposes of this predicate.\n\n","type":"Basics.Int -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"or","comment":" Create a `Predicate` that matches pipelines that match either or both of two\npredicates.\n","type":"ReviewPipelineStyles.Predicates.Predicate -> ReviewPipelineStyles.Predicates.Predicate -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"predicate","comment":" Given a function of type `Pipeline -> Bool`, create a `Predicate` from it.\nThis is only useful if you want to write custom predicates.\n","type":"(ReviewPipelineStyles.Predicates.Pipeline -> Basics.Bool) -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"predicateWithLookupTable","comment":" Given a function of type `ModuleNameLookupTable -> Pipeline -> Bool`, create\na `Predicate` from it. This is only useful if you want to write custom\npredicates and are going to need the full module name for expressions in the\npipeline.\n","type":"(Review.ModuleNameLookupTable.ModuleNameLookupTable -> ReviewPipelineStyles.Predicates.Pipeline -> Basics.Bool) -> ReviewPipelineStyles.Predicates.Predicate"},{"name":"separateATestFromItsLambda","comment":" Checks if a left \"pizza\" (`<|`) operator is used in the \"canonical\" fashion\nin a test suite, to separate the lambda containing the test from the `test`.\nAll of the following will \"pass\" this predicate, and all other `<|`'s will not:\n\n    import Test exposing (..)\n\n    suite =\n        describe \"tests\"\n            [ test \"foo\" <|\n                \\() ->\n                    a\n            , fuzz fooFuzz \"fuzz\" <|\n                \\foo ->\n                    a\n            , fuzz2 fooFuzz barFuzz \"fuzz2\" <|\n                \\foo bar ->\n                    a\n            , fuzz3 fooFuzz barFuzz bazFuzz \"fuzz3\" <|\n                \\foo bar baz ->\n                    a\n            , fuzzWith { runs = 117 } fooFuzz \"fuzzWith\" <|\n                \\foo ->\n                    a\n            ]\n\n","type":"ReviewPipelineStyles.Predicates.Predicate"},{"name":"spanMultipleLines","comment":" Checks whether or not a pipeline spans multiple lines of code.\n","type":"ReviewPipelineStyles.Predicates.Predicate"}],"binops":[]}]