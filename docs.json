[{"name":"ReviewPipelineStyles","comment":"\n\n@docs rule\n\n\n# Config\n\n@docs PipelineRule, forbid, that, exceptThoseThat\n\n\n## Failures\n\n@docs andCallThem, andReportCustomError\n\n\n## Fixes\n\n@docs andTryToFixThemBy\n\n\n## Pipeline Types\n\n@docs rightPizzaPipelines, leftPizzaPipelines, rightCompositionPipelines, leftCompositionPipelines, parentheticalApplicationPipelines\n\n","unions":[{"name":"PipelineRule","comment":" Configuration of this rule is in the form of a list of `PipelineRule`s. It\nshould be noted that these are hierarchical, i.e. only the first matching error\nwill be generated in the event that a pipeline would generate multiple errors.\n\nTo create a new `PipelineRule`, use [`forbid`](#forbid), then a pipeline type,\nthen the desired predicates and error. If no predicates are provided, the rule\nmatches **all** pipelines of that type. For example, to entirely forbid `<|` in\nyour project, you could use:\n\n    forbid leftPizzaPipelines\n        |> andCallThem \"forbidden <| pipeline\"\n\nOr, to forbid only `|>` pipelines that are extremely long, you could use:\n\n    forbid rightPizzaPipelines\n        |> that (haveMoreStepsThan 10)\n        |> andCallThem \"overly long |> pipeline\"\n\n","args":["pipelineType"],"cases":[]}],"aliases":[],"values":[{"name":"andCallThem","comment":" Provide a descriptive name for this type of failing pipeline. This will\nappear in the `elm-review` error generated and should give you a sense of what's\nwrong and how to fix it. Either this or\n[`andReportCustomError`](#andReportCustomError) must be the last thing in your\nrule.\n","type":"String.String -> ReviewPipelineStyles.PipelineRule anyType -> ReviewPipelineStyles.PipelineRule ()"},{"name":"andReportCustomError","comment":" Provide a fully custom error message for failing pipelines, with both\nmessage and details. Either this or [`andCallThem`](#andCallThem) must be the\nlast thing in your rule.\n","type":"String.String -> List.List String.String -> ReviewPipelineStyles.PipelineRule anyType -> ReviewPipelineStyles.PipelineRule ()"},{"name":"andTryToFixThemBy","comment":" Add fixes to a `PipelineRule`.\n","type":"ReviewPipelineStyles.Fixes.PipelineFix pipelineType -> ReviewPipelineStyles.PipelineRule pipelineType -> ReviewPipelineStyles.PipelineRule pipelineType"},{"name":"exceptThoseThat","comment":" Exclude (whitelist) pipelines that match a predicate from being forbidden.\n\n    forbid rightPizzaPipelines\n        |> that spanMultipleLines\n        |> exceptThoseThat (haveMoreStepsThan 5)\n\nNote that if `exceptThoseThat` is used multiple times, it is equivalent to using\n[`or`](#or). For example, the following two rules are equivalent:\n\n    forbid leftPizzaPipelines\n        |> exceptThoseThat\n            (doNot spanMultipleLines\n                |> or (haveFewerStepsThan 2)\n            )\n\n    forbid rightPizzaPipelines\n        |> exceptThoseThat (doNot spanMultipleLines)\n        |> exceptThoseThat (haveFewerStepsThan 2)\n\n","type":"ReviewPipelineStyles.Predicates.Predicate pipelineType -> ReviewPipelineStyles.PipelineRule pipelineType -> ReviewPipelineStyles.PipelineRule pipelineType"},{"name":"forbid","comment":" Forbid certain pipelines.\n","type":"ReviewPipelineStyles.Predicates.Operator pipelineType -> ReviewPipelineStyles.PipelineRule pipelineType"},{"name":"leftCompositionPipelines","comment":" The left composition operator is left function composition, i.e. `<<`. An\nexample of this pipeline is below:\n\n    foo << bar << baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator ReviewPipelineStyles.Predicates.CompositionPipeline"},{"name":"leftPizzaPipelines","comment":" The left \"pizza\" operator is left function application, i.e. `<|`. An\nexample of this pipeline is below:\n\n    foo <| bar <| baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator ReviewPipelineStyles.Predicates.ApplicationPipeline"},{"name":"parentheticalApplicationPipelines","comment":" Parenthetical application is actually the absence of a pipeline, but rather\nsuccessive function calls using parentheses, e.g.\n\n    foo (bar (baz (i (j k))))\n\n","type":"ReviewPipelineStyles.Predicates.Operator ReviewPipelineStyles.Predicates.ApplicationPipeline"},{"name":"rightCompositionPipelines","comment":" The right composition operator is right function composition, i.e. `>>`. An\nexample of this pipeline is below:\n\n    foo\n        >> bar\n        >> baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator ReviewPipelineStyles.Predicates.CompositionPipeline"},{"name":"rightPizzaPipelines","comment":" The right \"pizza\" operator is right function application, i.e. `|>`. An\nexample of this pipeline is below:\n\n    foo\n        |> bar\n        |> baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator ReviewPipelineStyles.Predicates.ApplicationPipeline"},{"name":"rule","comment":" Reports pipelines that are not valid by user-defined rules. For example,\nthe usage of `<|` or the usage of excessively-long `|>` pipelines.\n\n    config =\n        [ ReviewPipelineStyles.rule\n            [ forbid leftPizzaPipelines\n                |> andCallThem \"forbidden <| pipeline\"\n            , forbid rightPizzaPipelines\n                |> that (haveMoreStepsThan 10)\n                |> andCallThem \"overly long |> pipeline\"\n            ]\n        ]\n\nThis rule works with the following pipeline types:\n\n  - `|>`\n  - `<|`\n  - `>>`\n  - `<<`\n  - `foo (bar (baz (i (j k))))`\n\n\n## Fail\n\nBy the above config:\n\n    a =\n        Just <| foo bar\n\n    b =\n        foo\n            |> bar\n            |> baz\n            |> a\n            |> b\n            |> c\n            |> d\n            |> e\n            |> f\n            |> g\n            |> h\n            |> i\n            |> j\n            |> k\n\n\n## Success\n\nBy the above config:\n\n    a =\n        foo bar\n            |> Just\n\n    b =\n        foo\n            |> bar\n            |> baz\n            |> a\n            |> b\n            |> c\n            |> d\n\n\n## When (not) to enable this rule\n\nThis rule is useful when you have strong opinions about how functions should be\ncomposed/applied and/or want to enforce consistent code style in a project.\n\nThis rule is not useful if you don't care what sorts of pipelines are used in a\nproject.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template SiriusStarr/elm-review-pipeline-styles/example --rules ReviewPipelineStyles\n```\n\n","type":"List.List (ReviewPipelineStyles.PipelineRule ()) -> Review.Rule.Rule"},{"name":"that","comment":" Limit (blacklist) forbidden pipelines to those that match a specific\npredicate.\n\n    forbid rightPizzaPipelines\n        |> that spanMultipleLines\n\nNote that if `that` is used multiple times, it is equivalent to using\n[`or`](#or). For example, the following two rules are equivalent:\n\n    forbid rightPizzaPipelines\n        |> that\n            (spanMultipleLines\n                |> or (haveMoreStepsThan 5)\n            )\n\n    forbid rightPizzaPipelines\n        |> that spanMultipleLines\n        |> that (haveMoreStepsThan 5)\n\n","type":"ReviewPipelineStyles.Predicates.Predicate pipelineType -> ReviewPipelineStyles.PipelineRule pipelineType -> ReviewPipelineStyles.PipelineRule pipelineType"}],"binops":[]},{"name":"ReviewPipelineStyles.Fixes","comment":" This module contains various `PipelineFix`s that can be used to fix failing\npipelines.\n\nNote that all fixes will only run if it is **possible** to fix the pipeline that\nway, i.e. that the fix will not generate invalid code.\n\n\n## Fixes\n\n@docs eliminatingInputStep\n\n\n### Types\n\nThese are exposed only for the sake of type annotations; you shouldn't need to\nwork with them directly.\n\n@docs PipelineFix\n\n","unions":[],"aliases":[{"name":"PipelineFix","comment":" A means of fixing a pipeline, to (presumably) bring it stylistically inline\nwith what is desired.\n","args":["pipelineType"],"type":"Internal.Types.PipelineFix pipelineType"}],"values":[{"name":"eliminatingInputStep","comment":" A fix that eliminates the input step of a pipeline by applying it directly\nto the next step, e.g.\n\n    a =\n        foo |> bar |> baz\n\nbecomes\n\n    a =\n        bar foo |> baz\n\n","type":"ReviewPipelineStyles.Fixes.PipelineFix ReviewPipelineStyles.Predicates.ApplicationPipeline"}],"binops":[]},{"name":"ReviewPipelineStyles.Predicates","comment":" This module contains various `Predicate`s that can be used to filter\npipelines.\n\n\n## Combining Predicates\n\n@docs and, or, doNot\n\n\n## Predicates\n\n@docs spanMultipleLines, haveMoreStepsThan, haveFewerStepsThan, haveASimpleInputStep, haveAnUnnecessaryInputStep, haveAnInputStepOf, separateATestFromItsLambda\n\n\n## Nesting Predicates\n\n@docs haveAParent, haveAParentNotSeparatedBy, haveMoreNestedParentsThan, aLetBlock, aLambdaFunction, aFlowControlStructure, aDataStructure\n\n\n## Custom Predicates\n\nIf you need predicates beyond what is provided above, you can create them\nmanually by writing a function of type `Pipeline -> Bool` or\n`ModuleNameLookupTable -> Pipeline -> Bool` and using one of the functions\nbelow.\n\nUse the functions in\n[Getting Information About Pipelines](#getting-information-about-pipelines) to\nbuild your custom predicate.\n\n@docs predicate, predicateWithLookupTable\n\n\n## Getting Information About Pipelines\n\nNote that some of the types returned by these functions are from\n[`stil4m/elm-syntax`](https://package.elm-lang.org/packages/stil4m/elm-syntax/7.2.7/)\nif you need to work with them directly.\n\n@docs getSteps, getParents, getNode\n\n\n## Query Pipeline Types\n\n@docs isRightPizza, isLeftPizza, isRightComposition, isLeftComposition, isParentheticalApplication\n\n\n### Types\n\nThese are exposed only for the sake of type annotations; you shouldn't need to\nwork with them directly.\n\n@docs Predicate, Operator, Pipeline, NestedWithin, ApplicationPipeline, CompositionPipeline\n\n","unions":[],"aliases":[{"name":"ApplicationPipeline","comment":" Pipelines that are function application.\n","args":[],"type":"Internal.Types.ApplicationPipeline"},{"name":"CompositionPipeline","comment":" Pipelines that are function composition.\n","args":[],"type":"Internal.Types.CompositionPipeline"},{"name":"NestedWithin","comment":" The degree to which a parent or child is removed from a pipeline.\n","args":[],"type":"Internal.Types.NestedWithin"},{"name":"Operator","comment":" The operator type of a pipeline, e.g. `|>` or `<<`.\n","args":["pipelineType"],"type":"Internal.Types.Operator pipelineType"},{"name":"Pipeline","comment":" A detected pipeline. You only need be concerned with this type if you are\nwriting a manual predicate.\n","args":[],"type":"Internal.Types.Pipeline"},{"name":"Predicate","comment":" A predicate for filtering pipelines, or a logical combination of them.\n","args":["pipelineType"],"type":"Internal.Types.Predicate pipelineType"}],"values":[{"name":"aDataStructure","comment":" Within a tuple, list, or record in the surrounding pipeline.\n","type":"ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool"},{"name":"aFlowControlStructure","comment":" Within a `case` expression of `if...then` expression in the surrounding\npipeline.\n","type":"ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool"},{"name":"aLambdaFunction","comment":" Within a lambda function in the surrounding pipeline.\n","type":"ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool"},{"name":"aLetBlock","comment":" Either within a `let` declaration or in the `let` expression of a `let`\nblock from the surrounding pipeline.\n","type":"ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool"},{"name":"and","comment":" Create a `Predicate` that matches pipelines that match both of two\npredicates.\n","type":"ReviewPipelineStyles.Predicates.Predicate anyType -> ReviewPipelineStyles.Predicates.Predicate anyType -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"doNot","comment":" Negate a `Predicate`.\n","type":"ReviewPipelineStyles.Predicates.Predicate anyType -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"getNode","comment":" Get the outermost `Node` of a pipeline; you probably don't need to work with\nthis directly.\n","type":"ReviewPipelineStyles.Predicates.Pipeline -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression"},{"name":"getParents","comment":" Get the \"parent\" pipelines of the pipeline, i.e. a hierarchy of pipelines\nthat this pipeline is nested within (start of the list being the most immediate\nparent). Note that you can use the functions in\n[Nesting Predicates](#nesting-predicates) to interrogate the `NestedWithin`\ntype and in [Query Pipeline Types](#query-pipeline-types) for the\n`Operator` type.\n","type":"ReviewPipelineStyles.Predicates.Pipeline -> List.List ( ReviewPipelineStyles.Predicates.Operator (), ReviewPipelineStyles.Predicates.NestedWithin )"},{"name":"getSteps","comment":" Get the \"steps\" in the pipeline. Note that this is in \"logical\" order, e.g.\n`a 1 >> b >> c`, `c << b << a 1`, `a 1 |> b |> c`, `c <| b <| a 1`, and\n`c (b (a 1))` will all have the same steps of `[a 1, b, c]`.\n","type":"ReviewPipelineStyles.Predicates.Pipeline -> List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression)"},{"name":"haveAParent","comment":" Checks whether the pipeline is nested to any degree within another pipeline.\nNote that this is quite a strict requirement and you probably want to use one of\nthe other nesting predicates instead.\n","type":"ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"haveAParentNotSeparatedBy","comment":" Checks whether the immediate parent of a pipeline (if one exists) is not\nseparated by one of a list of acceptable abstractions.\n","type":"List.List (ReviewPipelineStyles.Predicates.NestedWithin -> Basics.Bool) -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"haveASimpleInputStep","comment":" Determine whether the pipeline has a simple input or not. This is somewhat\nsubjective, of course, so use [`haveAnInputStepOf`](#haveAnInputStepOf) if you want to customize its\nbehavior. A pipeline is considered to have a simple input if its input is **40\ncharacters or less**, is only a **single line**, and also:\n\nIs one of the following:\n\n    -- Unit\n    ()\n        |> foo\n\n    -- Name\n    a\n        |> foo\n\n    -- Prefix operator\n    (+)\n        |> foo\n\n    -- Int literal\n    1\n        |> foo\n\n    -- Hex literal\n    0x0F\n        |> foo\n\n    -- Float literal\n    1.5\n        |> foo\n\n    -- String literal\n    \"bar\"\n        |> foo\n\n    -- Char literal\n    'c'\n        |> foo\n\n    -- Record access function\n    .field\n        |> foo\n\nor is one of the following where all subexpressions are simple:\n\n    -- Tuple\n    ( a, \"b\" )\n        |> foo\n\n    -- Record\n    { a = \"value\" }\n        |> foo\n\n    -- List\n    []\n        |> foo\n\n    -- Record access\n    a.field\n        |> foo\n\n    -- Negation\n    elmFormatWontLetThisBeAnExample\n        |> foo\n\n    -- Parentheses\n    elmFormatWontLetThisBeAnExample\n        |> foo\n\n","type":"ReviewPipelineStyles.Predicates.Predicate ReviewPipelineStyles.Predicates.ApplicationPipeline"},{"name":"haveAnInputStepOf","comment":" Like [`haveASimpleInputStep`](#haveASimpleInputStep) but with a user-providable\nfunction to check if an expression is simple.\n","type":"(Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression -> Basics.Bool) -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"haveAnUnnecessaryInputStep","comment":" Determine whether the pipeline has an input step that simply isn't\nnecessary, e.g. `foo |> bar |> baz`, which may be written as `bar foo |> baz`.\n\nThis is not perfectly exhaustive as it does not consider operator precedence and\nthe like but will suffice for finding most simple cases.\n\nNote that this will potentially flag quite complex inputs, so you might want to\nuse [`haveASimpleInputStep`](#haveASimpleInputStep) instead, since that only\ndetects visually/cognitively simple inputs.\n\n","type":"ReviewPipelineStyles.Predicates.Predicate ReviewPipelineStyles.Predicates.ApplicationPipeline"},{"name":"haveFewerStepsThan","comment":" Checks whether the length of a pipeline is less than a specified number.\nNote that the length of a pipeline is the number of operators in it, e.g.\n\n    foo\n        |> bar\n        |> baz\n\nhas length **2** for the purposes of this predicate.\n\n","type":"Basics.Int -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"haveMoreNestedParentsThan","comment":" Checks whether the pipeline is nested to a greater degree than specified\nwithin other pipelines. For example, `haveMoreNestedParentsThan 1` will forbid\n\n    a =\n        foo\n            |> (bar <| (a |> b |> c))\n            |> baz\n\n","type":"Basics.Int -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"haveMoreStepsThan","comment":" Checks whether the length of a pipeline is longer than a specified number.\nNote that the length of a pipeline is the number of operators in it, e.g.\n\n    foo\n        |> bar\n        |> baz\n\nhas length **2** for the purposes of this predicate.\n\n","type":"Basics.Int -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"isLeftComposition","comment":" Check if an `Operator` is the left composition operator, i.e. `<<`. An\nexample of this pipeline is below:\n\n    foo << bar << baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator () -> Basics.Bool"},{"name":"isLeftPizza","comment":" Check if an `Operator` is the left \"pizza\" operator (left function\napplication), i.e. `<|`. An example of this pipeline is below:\n\n    foo <| bar <| baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator () -> Basics.Bool"},{"name":"isParentheticalApplication","comment":" Check if an `Operator` is simply parenthetical application (not an\noperator), i.e. successive function calls using parentheses, e.g.\n\n    foo (bar (baz (i (j k))))\n\n","type":"ReviewPipelineStyles.Predicates.Operator () -> Basics.Bool"},{"name":"isRightComposition","comment":" Check if an `Operator` is the right composition operator, i.e. `>>`. An\nexample of this pipeline is below:\n\n    foo\n        >> bar\n        >> baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator () -> Basics.Bool"},{"name":"isRightPizza","comment":" Check if an `Operator` is the right \"pizza\" operator (right function\napplication), i.e. `|>`. An example of this pipeline is below:\n\n    foo\n        |> bar\n        |> baz\n\n","type":"ReviewPipelineStyles.Predicates.Operator () -> Basics.Bool"},{"name":"or","comment":" Create a `Predicate` that matches pipelines that match either or both of two\npredicates.\n","type":"ReviewPipelineStyles.Predicates.Predicate anyType -> ReviewPipelineStyles.Predicates.Predicate anyType -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"predicate","comment":" Given a function of type `Pipeline -> Bool`, create a `Predicate` from it.\nThis is only useful if you want to write custom predicates. Note that this will\nallow you to create predicates that match any type of pipeline, so be careful in\nhow you use it.\n","type":"(ReviewPipelineStyles.Predicates.Pipeline -> Basics.Bool) -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"predicateWithLookupTable","comment":" Given a function of type `ModuleNameLookupTable -> Pipeline -> Bool`, create\na `Predicate` from it. This is only useful if you want to write custom\npredicates and are going to need the full module name for expressions in the\npipeline. Note that this will allow you to create predicates that match any type\nof pipeline, so be careful in how you use it.\n","type":"(Review.ModuleNameLookupTable.ModuleNameLookupTable -> ReviewPipelineStyles.Predicates.Pipeline -> Basics.Bool) -> ReviewPipelineStyles.Predicates.Predicate anyType"},{"name":"separateATestFromItsLambda","comment":" Checks if a left \"pizza\" (`<|`) operator is used in the \"canonical\" fashion\nin a test suite, to separate the lambda containing the test from the `test`.\nAll of the following will \"pass\" this predicate, and all other `<|`'s will not:\n\n    import Test exposing (..)\n\n    suite =\n        describe \"tests\"\n            [ test \"foo\" <|\n                \\() ->\n                    a\n            , fuzz fooFuzz \"fuzz\" <|\n                \\foo ->\n                    a\n            , fuzz2 fooFuzz barFuzz \"fuzz2\" <|\n                \\foo bar ->\n                    a\n            , fuzz3 fooFuzz barFuzz bazFuzz \"fuzz3\" <|\n                \\foo bar baz ->\n                    a\n            , fuzzWith { runs = 117 } fooFuzz \"fuzzWith\" <|\n                \\foo ->\n                    a\n            ]\n\n","type":"ReviewPipelineStyles.Predicates.Predicate ReviewPipelineStyles.Predicates.ApplicationPipeline"},{"name":"spanMultipleLines","comment":" Checks whether or not a pipeline spans multiple lines of code.\n","type":"ReviewPipelineStyles.Predicates.Predicate anyType"}],"binops":[]}]